{"version":3,"sources":["../node_modules/jison/node_modules/source-map/lib/source-map sync","compiler/lexer/lexer.js","compiler/lexer/parser.js","compiler/semantic/result/index.js","compiler/semantic/symbolsTable/getKey.js","compiler/semantic/symbolsTable/getSymbolsTable.js","compiler/semantic/symbolsTable/getSymbol.js","compiler/semantic/symbolsTable/insertSymbol.js","compiler/semantic/semanticAnalysis/treatProgram.js","compiler/semantic/semanticAnalysis/treatVarDeclaration.js","compiler/semantic/aritmethicOperation.js","compiler/semantic/symbolsTable/updateSymbol.js","compiler/semantic/semanticAnalysis/treatVarManipulation.js","compiler/semantic/booleanOperation.js","compiler/semantic/semanticAnalysis/treatIf.js","compiler/semantic/semanticAnalysis/treatWhile.js","compiler/semantic/semanticAnalysis/index.js","compiler/semantic/symbolsTable/clearSymbolsTable.js","App.js","compiler/semantic/index.js","index.js"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","Lexer","require","lexer","macros","rules","parser","generateParser","headRule","result","appendResult","appendix","getSemanticErrorMessage","getResult","message","getKey","cadeia","categoria","symbolsTable","getSymbolsTable","getSymbol","hash","insertSymbol","token","tipo","valor","key","utilizada","treatProgram","parseArray","proximoParse","treatVarDeclaration","_","indiceProximaVirgula","undefined","parseAtual","tokenParseAtual","tipoParseAtual","resolveSimpleExpression","num1","operacao","num2","deu_certo","resultado","Number","parseInt","updateSymbol","symbol","treatVarManipulation","valorFinal","proximaOperacao","rightSideToken","rightSideValue","parserTipo","proximoValor","resolveBooleanExpression","bool1","bool2","NaN","resolveNumericBooleanExpression","treatIf","logicalExpr","i","push","console","log","splice","boolValue","stateArray","blockMode","value","length","map","parsingObj","semanticAnalysis","treatWhile","iterate","clone","semanticTreatment","currentToken","clearSymbolsTable","Object","forEach","App","useState","file","setFile","lexerResult","setLexerResult","semanticResult","setSemanticResult","lexerToParser","setLexerToParser","setErroSintatico","table","setTable","useEffect","parsing_stack","errors","res","parseToken","has_errors","error","expected","got","analyzeLexer","print","setInput","match","lex","resultToParser","chave","className","type","onChange","evt","files","target","reader","FileReader","readAsText","onload","onerror","accept","onClick","disabled","for","event","item","ReactDOM","createRoot","document","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.0057c377.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 11;","const Lexer = require(\"jison-lex\")\nconst Jison = require('jison')\n\nconst lexemes = {\n    macros: {\n        \"DIGIT\": \"[0-9]\",\n        \"INVALID_IDENTIFIER\": \"[A-Za-z_][A-Za-z_0-9]{15,}\",\n        \"VALID_IDENTIFIER\": \"[A-Za-z_][A-Za-z_0-9]{0,14}\",\n        \"LINE_FEED\": \"(\\\\r|\\\\n|\\\\r\\\\n)\",\n        \"TYPES\": \"(int|boolean)\"\n    },\n    rules: [\n        // Palavras reservadas\n        [\"program\", \"return ['PROGRAM', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"var\", \"return ['VAR', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"{TYPES}\", \"return ['TYPE', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"begin\", \"return ['BEGIN', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"end\", \"return ['END', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"procedure\", \"return ['PROCEDURE', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"if\", \"return ['IF', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"then\", \"return ['THEN', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"else\", \"return ['ELSE', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"while\", \"return ['WHILE', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"do\", \"return ['DO', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n\n        // Operadores\n        [\":=\", \"return ['ASSIGN', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"(<>|<=|<|>=|>|=)\", \"return ['RELATIONAL_OP', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"(\\\\*|div|and)\", \"return ['ARITMETHIC_OP_FACTOR', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"(\\\\+|\\\\-)\", \"return ['ARITMETHIC_OP_SIMPLE', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"or\", \"return ['OR', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"not\", \"return ['NOT', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n\n        // Identificadores e números\n        [\"{INVALID_IDENTIFIER}\", \"return ['INVALID_ID_LENGTH', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"{VALID_IDENTIFIER}\", \"return ['ID', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"{DIGIT}{9,}\", \"return ['OVERFLOW_NUMBER', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"{DIGIT}{1,8}\", \"return ['NUMBER', yytext, [yylloc.first_line, yylloc.first_column]];\"],\n\n        // Delimitadores\n        [\",\", \"return ['COLON', ',', [yylloc.first_line, yylloc.first_column]];\"],\n        [\";\", \"return ['SEMICOLON', ';', [yylloc.first_line, yylloc.first_column]];\"],\n        [\"\\\\.\", \"return ['DOT', '.', [yylloc.first_line, yylloc.first_column]];\"],\n        [\" \", \"return;\"],\n        [\"\\t\", \"return;\"],\n        [\"{LINE_FEED}+\", \"return;\"],\n\n        // Comentários\n        [\"\\/\\/.*{LINE_FEED}+\", \"return;\"],\n        [\"\\\\\\{([^*]*?)\\\\\\}\", \"return;\"],\n        [\"\\\\\\{(\\\\*(?!\\/)|[^*])*\", \"return ['UNEXPECTED_EOF', null, [yylloc.first_line, yylloc.first_column]];\"],\n\n        // Parênteses\n        [\"\\\\(\", \"return ['LPAREN', '(', [yylloc.first_line, yylloc.first_column]]\"],\n        [\"\\\\)\", \"return ['RPAREN', ')', [yylloc.first_line, yylloc.first_column]]\"],\n\n\n\n        // Declaração de tipo\n        [\":\", \"return ['TYPE_DECLARATION', ':', [yylloc.first_line, yylloc.first_column]];\"],\n\n        // Final de arquivo\n        [\"\\\\.\", \"return ['EOP', null, [yylloc.first_line, yylloc.first_column]];\"],\n        [\"$\", \"return ['EOF', null, [yylloc.first_line, yylloc.first_column]];\"],\n\n        // Símbolos fora do alfabeto\n        [\"[^*]\", \"return ['UNEXPECTED_TOKEN', yytext, [yylloc.first_line, yylloc.first_column]]\"],\n\n    ]\n}\n\n\nvar lexer = new Lexer(lexemes);\n\n\nexport default lexer\n","import { generateParser } from '@ellyzeul_/ll1-parser'\n\nconst parser = generateParser({\n    headRule: '<PROGRAM>',\n    '<PROGRAM>': 'PROGRAM ID SEMICOLON <BLOCK> DOT <EOF>',\n    '<BLOCK>': '<COMP_COMAND> | <PART_VAR_DECLARATION> <PART_SUBROUTINE_DECLARATION> <COMP_COMAND>',\n    '<PART_VAR_DECLARATION>': '<VAR_DECLARATION> SEMICOLON <REMINDER_PART_VAR_DECLARATION> | v',\n    '<REMINDER_PART_VAR_DECLARATION>': '<VAR_DECLARATION> SEMICOLON <REMINDER_PART_VAR_DECLARATION> | v',\n    '<VAR_DECLARATION>': 'TYPE ID <ID_LIST>',\n    '<ID_LIST>': 'COLON ID <ID_LIST> | v',\n    '<PART_SUBROUTINE_DECLARATION>': '<PROCEDURE_DECLARATION> SEMICOLON <PART_SUBROUTINE_DECLARATION> | v',\n    '<PROCEDURE_DECLARATION>': 'PROCEDURE ID <FORMAL_PARAMS> SEMICOLON <BLOCK>',\n    '<FORMAL_PARAMS>': 'LPAREN <FORMAL_PARAMS_SECTION> RPAREN | v',\n    '<FORMAL_PARAMS_SECTION>': 'VAR ID <ID_LIST> TYPE_DECLARATION TYPE <MORE_FORMAL_PARAMS_SECTION> | ID <ID_LIST> TYPE_DECLARATION TYPE <MORE_FORMAL_PARAMS_SECTION>',\n    '<MORE_FORMAL_PARAMS_SECTION>': 'SEMICOLON <FORMAL_PARAMS_SECTION> <MORE_FORMAL_PARAMS_SECTION> | v',\n    '<COMP_COMAND>': 'BEGIN <COMAND> <COMAND_LIST> END',\n    '<COMAND>': 'ID <ATTR_OR_PROCEDURE> | <COMP_COMAND> | <CODITIONAL_COMAND_1> | <LOOP_COMAND_1>',\n    '<COMAND_LIST>': 'SEMICOLON <COMAND> <COMAND_LIST> | v',\n    '<ATTR_OR_PROCEDURE>': 'ASSIGN <EXPRESSION> | <PROCEDURE_CALL>',\n    '<EXPRESSION>': '<SIMPLE_EXPRESSION> <REMAINDER_EXPRESSION>',\n    '<REMAINDER_EXPRESSION>': 'RELATIONAL_OP <SIMPLE_EXPRESSION> | v',\n    '<SIMPLE_EXPRESSION>': 'ARITMETHIC_OP_SIMPLE <TERM> <REMAINDER_SIMPLE_EXPRESSION_2> | <TERM> <REMAINDER_SIMPLE_EXPRESSION_2>',\n    '<REMAINDER_SIMPLE_EXPRESSION_2>': 'ARITMETHIC_OP_SIMPLE <TERM> <REMAINDER_SIMPLE_EXPRESSION_2> | OR <TERM> <REMAINDER_SIMPLE_EXPRESSION_2> | v',\n    '<TERM>': '<FACTOR> <REMINDER_TERM>',\n    '<REMINDER_TERM>': 'ARITMETHIC_OP_FACTOR <FACTOR> <REMINDER_TERM> | v',\n    '<FACTOR>': 'ID | NUMBER | LPAREN <EXPRESSION> RPAREN | NOT <FACTOR>',\n    '<PROCEDURE_CALL>': 'LPAREN <EXPRESSION> <EXPRESSION_LIST> RPAREN | v',\n    '<EXPRESSION_LIST>': 'COLON <EXPRESSION> | v',\n    '<CODITIONAL_COMAND_1>': 'IF <EXPRESSION> THEN <OPT_BLOCK> <OPTIONAL_ELSE>',\n    '<OPTIONAL_ELSE>': 'ELSE <OPT_BLOCK> | v',\n    '<LOOP_COMAND_1>': 'WHILE <EXPRESSION> DO <OPT_BLOCK>',\n    '<OPT_BLOCK>': '<COMP_COMAND>', // | <COMAND> // Nao esta funcionando por causa da recursao em <COMAND>\n    '<EOF>': 'EOF'\n})\n\nexport default parser\n","let result = \"\"\n\nexport const appendResult = (appendix) => result = result + getSemanticErrorMessage(appendix)\n\nexport const getResult = () => result\n\nconst getSemanticErrorMessage = (message) =>\n`Erro semântico\n${message}\n\n-------------------------------------------------\n\n`\n","const getKey = (cadeia, categoria) => `${cadeia}-${categoria}`\n\nexport default getKey\n","const symbolsTable = {}\n\nconst getSymbolsTable = () => symbolsTable\n\nexport default getSymbolsTable\n","import getSymbolsTable from \"./getSymbolsTable\"\n\nconst symbolsTable = getSymbolsTable()\n\nconst getSymbol = (hash) => symbolsTable[hash]\n\nexport default getSymbol\n","import getKey from \"./getKey\"\nimport getSymbol from \"./getSymbol\"\nimport getSymbolsTable from \"./getSymbolsTable\"\n\nconst insertSymbol = (cadeia, token, categoria, tipo = null, valor = null) => {\n    const symbolsTable = getSymbolsTable()\n    const key = getKey(cadeia, categoria)\n    if (!getSymbol(key)) {\n        symbolsTable[key] = {\n            cadeia,\n            token,\n            categoria,\n            tipo,\n            valor,\n            utilizada: false\n        }\n        return true\n    }\n    return false\n}\n\nexport default insertSymbol\n","import insertSymbol from \"../symbolsTable/insertSymbol\"\n\nconst treatProgram = (parseArray, token) => {\n    const proximoParse = parseArray[1]\n    insertSymbol(\n        proximoParse[1],\n        token,\n        'PROG'\n    )\n}\n\nexport default treatProgram\n","import { appendResult } from \"../result\"\nimport insertSymbol from \"../symbolsTable/insertSymbol\"\n\nconst treatVarDeclaration = (parseArray, _) => {\n  let indiceProximaVirgula = 1\n  let tipo = parseArray[0][1]\n\n  while (parseArray[indiceProximaVirgula] !== undefined) {\n    const parseAtual = parseArray[indiceProximaVirgula]\n    const tokenParseAtual = parseAtual[1]\n    const tipoParseAtual = parseAtual[0]\n    if (!insertSymbol(\n      tokenParseAtual,\n      tipoParseAtual,\n      'VAR',\n      tipo\n    )) {\n      appendResult(`A variável ${tokenParseAtual} já foi declarada...`)\n      return\n    }\n\n    indiceProximaVirgula += 2\n  }\n}\n\nexport default treatVarDeclaration\n","const operacaoRecursiva = (arrayDeEntrada) => {\n  // arrayDeEntrada.map(item => {\n  //     if (item.)\n  // })\n}\n\nconst resolveSimpleExpression = (num1, operacao, num2) => {\n  if ((num1 == 'false' || num1 == 'true') || (num2 == 'false' || num2 == 'true'))\n    return {\n      deu_certo: false,\n      resultado: undefined\n    }\n  num1 = Number.parseInt(num1)\n  num2 = Number.parseInt(num2)\n  switch (operacao) {\n    case '+':\n      return {\n        deu_certo: true,\n        resultado: num1 + num2,\n      }\n    case '-':\n      return {\n        deu_certo: true,\n        resultado: num1 - num2,\n      }\n    case '*':\n      return {\n        deu_certo: true,\n        resultado: num1 * num2,\n      }\n    case 'div':\n      return {\n        deu_certo: true,\n        resultado: Number.parseInt(num1 / num2),\n      }\n\n    default:\n      return {\n        deu_certo: false,\n        resultado: undefined,\n      }\n  }\n}\n\nexport default resolveSimpleExpression\n","import { appendResult } from \"../result\"\nimport getKey from \"./getKey\"\nimport getSymbol from \"./getSymbol\"\n\nconst updateSymbol = (cadeia, categoria, valor) => {\n  const key = getKey(cadeia, categoria)\n  const symbol = getSymbol(key)\n  if (!symbol) {\n    appendResult(`${cadeia} não declarada`)\n    return false\n  }\n  const type = (valor === 'false' || valor == 'true') ? 'boolean' : 'int'\n  if (type !== symbol.tipo) {\n    appendResult(`${valor} tem tipo diferente da declaração da variável ${cadeia}`)\n    return false\n  }\n\n  symbol.valor = valor\n  symbol.utilizada = true\n\n  return true\n}\n\nexport default updateSymbol\n","import resolveSimpleExpression from \"../aritmethicOperation\"\nimport getKey from \"../symbolsTable/getKey\"\nimport getSymbol from \"../symbolsTable/getSymbol\"\nimport updateSymbol from \"../symbolsTable/updateSymbol\"\n\nconst treatVarManipulation = (parseArray, token) => {\n    if (parseArray[1][0] !== \"ASSIGN\") return\n\n    let proximaOperacao = 3\n    let valorFinal\n    const [rightSideToken, rightSideValue, _] = parseArray[2]\n    if ((rightSideToken !== \"NUMBER\") && (rightSideValue !== \"true\") && (rightSideValue !== \"false\")) {\n        valorFinal = getSymbol(getKey(rightSideValue, 'VAR')).valor\n    }\n    else\n        valorFinal = parseArray[2][1]\n    while (parseArray[proximaOperacao] !== undefined) {\n        const parseAtual = parseArray[proximaOperacao]\n        const parserTipo = parseAtual[0]\n\n        const proximoValor = parseArray[proximaOperacao + 1][0] === \"NUMBER\"\n            ? parseArray[proximaOperacao + 1][1]\n            : getSymbol(getKey(parseArray[proximaOperacao + 1][1], 'VAR')).valor\n\n        if (parserTipo == \"ARITMETHIC_OP_SIMPLE\" || parserTipo == \"ARITMETHIC_OP_FACTOR\") {\n            valorFinal = resolveSimpleExpression(valorFinal, parseAtual[1], proximoValor).resultado\n        }\n\n        proximaOperacao += 2\n    }\n\n    updateSymbol(parseArray[0][1], 'VAR', valorFinal)\n}\n\nexport default treatVarManipulation\n","import getKey from \"./symbolsTable/getKey\"\nimport getSymbol from \"./symbolsTable/getSymbol\"\n\nconst operacaoRecursiva = (arrayDeEntrada) => {\n    // arrayDeEntrada.map(item => {\n    //     if (item.)\n    // })\n}\n\nconst resolveNumericBooleanExpression = (num1, operacao, num2) => {\n    num1 = Number.parseInt(num1)\n    num2 = Number.parseInt(num2)\n\n    if (num1 == NaN || num2 == NaN)\n        return {\n            deu_certo: false,\n            resultado: undefined\n        }\n\n    switch (operacao) {\n        case \">\":\n            return {\n                deu_certo: true,\n                resultado: num1 > num2\n            }\n        case \"<\":\n            return {\n                deu_certo: true,\n                resultado: num1 < num2\n            }\n        case \">=\":\n            return {\n                deu_certo: true,\n                resultado: num1 >= num2\n            }\n        case \"<=\":\n            return {\n                deu_certo: true,\n                resultado: num1 <= num2\n            }\n        case \"=\":\n            return {\n                deu_certo: true,\n                resultado: num1 === num2\n            }\n        case \"<>\":\n            return {\n                deu_certo: true,\n                resultado: num1 !== num2\n            }\n        default:\n            break;\n    }\n}\n\nconst resolveBooleanExpression = (bool1, operacao, bool2) => {\n    bool1 = bool1[0] === \"NUMBER\"\n        ? bool1[1]\n        : getSymbol(getKey(bool1[1], \"VAR\")).valor\n\n    bool2 = bool2[0] === \"NUMBER\"\n        ? bool2[1]\n        : getSymbol(getKey(bool2[1], \"VAR\")).valor\n\n    if ((bool1 != 'false' && bool1 != 'true') || (bool2 != 'false' && bool2 != 'true'))\n        return resolveNumericBooleanExpression(bool1, operacao, bool2)\n\n    switch (bool1) {\n        case \"true\":\n            bool1 = true\n            break;\n        case \"false\":\n            bool1 = false\n            break;\n        default:\n            return {\n                deu_certo: false,\n                resultado: undefined\n            }\n    }\n    switch (bool2) {\n        case \"true\":\n            bool2 = true\n            break;\n        case \"false\":\n            bool2 = false\n            break;\n        default:\n            if (operacao == 'not')\n                return {\n                    deu_certo: true,\n                    resultado: !bool1\n                }\n            return {\n                deu_certo: false,\n                resultado: undefined\n            }\n    }\n\n    switch (operacao) {\n        case 'or':\n            return {\n                deu_certo: true,\n                resultado: bool1 || bool2,\n            }\n        case 'and':\n            return {\n                deu_certo: true,\n                resultado: bool1 && bool2,\n            }\n        default:\n            return {\n                deu_certo: false,\n                resultado: undefined,\n            }\n    }\n}\n\nexport default resolveBooleanExpression\n","import resolveBooleanExpression from \"../booleanOperation\";\nimport getKey from \"../symbolsTable/getKey\";\nimport getSymbol from \"../symbolsTable/getSymbol\";\nimport semanticAnalysis from \"./index\"\n\nconst treatIf = (parseArray, _) => {\n    const logicalExpr = []\n\n    const strToBool = (boolStr) => {\n        if (boolStr === \"true\")\n            return true\n        if (boolStr === \"false\")\n            return false\n        return undefined\n    }\n\n    let i = 2\n    for (; parseArray[i][0] !== \"RPAREN\"; i++) {\n        logicalExpr.push(parseArray[i])\n    }\n\n    console.log(\"logic\", logicalExpr)\n    parseArray.splice(0, i + 2)\n    let stateArray = []\n    let blockMode = { value: 0 }\n    let boolValue\n    if (logicalExpr.length == 1) {\n        boolValue = getSymbol(getKey(logicalExpr[0][1], \"VAR\")).valor\n        if (boolValue)\n            parseArray.map(parsingObj => semanticAnalysis(parsingObj, stateArray, blockMode))\n    }\n\n    else\n        for (let i = 0; i < logicalExpr.length; i += 3) {\n            boolValue = resolveBooleanExpression(\n                logicalExpr[i],\n                logicalExpr[i + 1][1],\n                logicalExpr[i + 2]).resultado\n            console.log(\"bool\", boolValue);\n            if (boolValue) parseArray.map(parsingObj => semanticAnalysis(parsingObj, stateArray, blockMode))\n        }\n\n    return boolValue\n}\n\nexport default treatIf\n","import getKey from \"../symbolsTable/getKey\"\nimport getSymbol from \"../symbolsTable/getSymbol\"\nimport treatIf from \"./treatIf\"\n\nconst treatWhile = (parseArray, _) => {\n    let iterate = true\n    while (iterate) {\n        console.log(getSymbol(getKey(\"a\", \"VAR\")))\n        console.log(getSymbol(getKey(\"b\", \"VAR\")))\n        let clone = [...parseArray]\n        console.log(\"interacao\", parseArray[0], parseArray[1]);\n        iterate = treatIf(clone, _)\n    }\n}\n\nexport default treatWhile","import treatProgram from \"./treatProgram\"\nimport treatVarDeclaration from \"./treatVarDeclaration\"\nimport treatVarManipulation from \"./treatVarManipulation\"\nimport treatIf from \"./treatIf\"\nimport treatWhile from \"./treatWhile\"\nimport { getResult } from \"../result\"\n\nconst semanticTreatment = {\n    'PROGRAM': treatProgram,\n    'TYPE': treatVarDeclaration,\n    'ID': treatVarManipulation,\n    'IF': treatIf,\n    'WHILE': treatWhile\n}\n\nconst semanticAnalysis = (parsingObj, parseArray, blockMode) => {\n    if(getResult() !== '') return\n\n    const token = parsingObj[0]\n\n    if (token === \"IF\" || token === \"WHILE\") {\n        blockMode.value = 1\n    }\n\n    if (token === \"END\")\n        blockMode.value = 2\n\n    if ((token === \"BEGIN\" || token === \"END\") && blockMode.value === 0) return\n\n    if (token !== \"SEMICOLON\" || blockMode.value === 1) {\n        parseArray.push(parsingObj)\n        return\n    }\n\n\n    const currentToken = parseArray[0][0]\n\n    if (!semanticTreatment[currentToken]) return\n\n    semanticTreatment[currentToken](parseArray, currentToken)\n    parseArray.length = 0\n}\n\nexport default semanticAnalysis\n","import getSymbolsTable from \"./getSymbolsTable\"\n\nconst clearSymbolsTable = () => {\n  const symbolsTable = getSymbolsTable()\n\n  Object.keys(symbolsTable).forEach(key => delete symbolsTable[key])\n}\n\nexport default clearSymbolsTable\n","import './App.css';\nimport React, { useEffect, useState } from 'react';\nimport lexer from './compiler/lexer/lexer';\nimport parser from './compiler/lexer/parser';\nimport { clearSymbolsTable, getSemanticResult, getSymbolsTable, semanticAnalysis } from './compiler/semantic';\n\nconst getSyntaticErrorMessage = (errors) =>\n    `Erro sintático! \nEsperado: ${errors.map(error => error.expected)}.\nRecebido: ${errors[0].got}.\n-------------------------------------------------\n\n`\n\nfunction App() {\n    const [file, setFile] = useState('')\n    const [lexerResult, setLexerResult] = useState('')\n    const [semanticResult, setSemanticResult] = useState({})\n    const [lexerToParser, setLexerToParser] = useState([])\n    const [erroSintatico, setErroSintatico] = useState(false)\n    const [table, setTable] = useState([])\n    let tabelaSimbolos = {}\n\n    const inputFile = (evt) => {\n        const files = evt.target.files[0];\n        const reader = new FileReader();\n        reader.readAsText(files, \"UTF-8\");\n        reader.onload = (evt) => setFile(evt.target.result)\n        reader.onerror = () => setFile(\"Erro ao ler o arquivo\")\n    }\n\n    useEffect(() => {\n        setTable([])\n        setErroSintatico(false)\n        if (lexerToParser.length === 0)\n            return\n\n        let result = ''\n        parser.parsing_stack = null\n\n        lexerToParser.map(parsingObj => {\n            let token = parsingObj[0]\n            let res = parser.parseToken(token)\n            if (res.has_errors) {\n                result += getSyntaticErrorMessage(res.errors)\n                setErroSintatico(true)\n            }\n        })\n        setLexerResult(result || \"Análise concluída com sucesso!\")\n    }, [lexerToParser])\n\n\n\n    const analyzeLexer = (print = true) => {\n        setTable([])\n        try {\n            lexer.setInput(file)\n            let match = lexer.lex();\n            let result = ''\n            let resultToParser = []\n            while (match != 1) {\n                result += match + \"\\n\"\n                resultToParser.push(match)\n                match = lexer.lex();\n            }\n\n            if (print)\n                setLexerResult(result)\n            else\n                setLexerToParser(resultToParser)\n\n        }\n        catch (error) {\n            console.log(error);\n        }\n    }\n\n\n    const analyzeParser = () => analyzeLexer(false)\n\n    const analyzeSemantic = () => {\n        const symbolsTable = getSymbolsTable()\n        let parseArray = []\n        const blockMode = { value: 0 }\n        clearSymbolsTable()\n        lexerToParser.map(parsingObj => {\n            semanticAnalysis(parsingObj, parseArray, blockMode)\n        })\n        let error = getSemanticResult()\n        if (error != '') {\n            setLexerResult(error)\n            return\n        }\n        setSemanticResult(symbolsTable)\n    }\n\n    useEffect(() => {\n        let table = []\n        for (const chave in semanticResult) {\n            table.push(<tr key={chave}>\n                <td>{semanticResult[chave].cadeia}</td>\n                <td>{semanticResult[chave].token}</td>\n                <td>{semanticResult[chave].categoria}</td>\n                <td>{semanticResult[chave].tipo}</td>\n                <td>{semanticResult[chave].valor}</td>\n                <td>{semanticResult[chave].utilizada + \"\"}</td>\n            </tr>)\n        }\n        setTable(table)\n    }, [semanticResult])\n\n\n    return (\n        <div className=\"App\">\n\n            <div className=\"divButton\">\n                <input type=\"file\" id=\"fileUpload\" onChange={inputFile} accept=\".lalg, .pas, .txt\"></input>\n                <button id=\"analyzeLexer\" onClick={analyzeLexer} disabled={file === ''}>Analize Léxica</button>\n                <button id=\"analyzeParser\" onClick={analyzeParser} disabled={file === ''}>Analize Sintática</button>\n                <button id=\"analyzeSemantic\" onClick={analyzeSemantic} disabled={lexerToParser.length === 0}>Analize Semântica</button>\n            </div>\n            <div className=\"divCode\">\n                <div className=\"divLabel\">\n                    <label for=\"codeArea\">Código</label>\n                    <textarea className=\"code\" id=\"codeArea\" value={file} onChange={(event) => setFile(event.target.value)}></textarea>\n                </div>\n                {table.length == 0 ?\n                    <div className=\"divLabel\">\n                        <label for=\"lexerArea\">Separação Léxica</label>\n                        <textarea className=\"code\" id=\"lexerArea\" value={lexerResult} ></textarea>\n                    </div>\n                    :\n                    <div className=\"divLabel\">\n                        <table>\n                            <thead>\n                                <tr>\n                                    <th>Cadeia</th>\n                                    <th>Token</th>\n                                    <th>Categoria</th>\n                                    <th>Tipo</th>\n                                    <th>Valor</th>\n                                    <th>Utilizada</th>\n                                </tr>\n                            </thead>\n                            <tbody>\n                                {table.map(item => item)}\n                            </tbody>\n                        </table>\n                    </div>\n                }\n\n            </div>\n\n        </div>\n    );\n}\n\nexport default App;\n","import { getResult } from \"./result\"\nimport semanticAnalysis from \"./semanticAnalysis\"\nimport clearSymbolsTable from \"./symbolsTable/clearSymbolsTable\"\nimport getSymbolsTable from \"./symbolsTable/getSymbolsTable\"\n\nexport { semanticAnalysis, getSymbolsTable, clearSymbolsTable }\n\nexport const getSemanticResult = () => getResult()\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>\n);\n\n"],"sourceRoot":""}